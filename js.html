<!DOCTYPE HTML>
<html lang="zh-cn">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>js代码规范</title>
    <link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link href="./assets/css/main.css" rel="stylesheet">
  </head>
  <body>
    <section class="container">
      <section class="hd">
        <a href="./js.html" class="row active">js规范</a>
        <a href="./css.html" class="row">css规范</a>
        <a href="./html.html" class="row">html规范</a>
        <a href="./name.html" class="row">命名规范</a>
        <a href="./image.html" class="row">图片规范</a>
      </section>

      <ul class="main">
        <li class="title-s1">js代码规范</li>
        <li class="row-s1">所有功能均有js注释</li>
        <li class="row-s1">使用空格代替tab</li>
        <li class="row-s1">代码缩紧使用2个空格</li>
        <li class="row-s1">变量命名使用驼峰方式, 首字母小写: 例如: userList</li>
        <li class="row-s1">函数命名使用驼峰方式, 首字母小写: 例如: getUserInfo</li>
        <li class="row-s1">变量、函数命名使用英文, 如果英文太长使用简写</li>
        <li class="title-s2">公共方法、变量</li>
        <li class="row-pre">
<pre>
/* 公共的方法、全局变量、常量提取出，例如放在来放在common/utils.js中 */

// utils.js
const formatDate = () => {

}

const sendPost = () => {

}

export {
  formatDate,
  sendPost
}

// config.js
const apiUrl = 'https://www.xxx.com';

export {
  apiUrl
}
</pre>
        </li>
        <li class="title-s2">组件化</li>
        <li class="row-pre">
<pre>
超过1个地方使用的均组件化, 注意组件的灵活性.
</pre>
        <li class="title-s2">分号</li>
        <li class="row-pre">
<pre>
/* 每行代码结尾使用都需要加上分号 */

// bad
let a = 1


// good
let a = 1;
</pre>
        </li>
        <li class="title-s2">const、let</li>
        <li class="row-pre">
<pre>
内容不变的使用const定义
const a = 1;

内容会改变的时候用let定义
let a = 1;
if (a == 1) {
  a = 2;
}
</pre>
        <li class="title-s2">分号</li>
        <li class="row-pre">
<pre>
/* 每行代码结尾使用都需要加上分号 */

// bad
let a = 1


// good
let a = 1;
</pre>
        </li>
        <li class="title-s2">const、let</li>
        <li class="row-pre">
<pre>
内容不变的使用const定义
const a = 1;

内容会改变的时候用let定义
let a = 1;
if (a == 1) {
  a = 2;
}
</pre>
        </li>
        <li class="title-s2">对象</li>
        <li class="row-pre">
<pre>
/* 请使用字面量值创建对象 */

// bad
const a = new Object{}

// good
const a = {}
</pre>
          </li>
        <li class="row-pre">
<pre>
/* 别使用保留字作为对象的键值 */

// bad
const a = {
  default: {},  // default 是保留字
  common: {}
}

// good
const a = {
  defaults: {},
  common: {}
}
</pre>
        </li>
        <li class="row-pre">
<pre>
/* 请使用对象方法的简写方式 */

// bad
const item = {
  value: 1,

  addValue: function (val) {
    return item.value + val
  }
}

// good
const item = {
  value: 1,

  addValue(val) {
    return item.value + val
  }
}
</pre>
        </li>
        <li class="row-pre">
<pre>
/* 请使用对象属性值的简写方式 */

const job = 'FrontEnd'

// bad
const item = {
  job: job
}

// good
const item = {
  job
}
</pre>
        </li>
        <li class="title-s2">数组</li>
        <li class="row-pre">
<pre>
/* 请使用字面量值创建数组 */

// bad
const items = new Array()

// good
const items = []
</pre>
        </li>
        <li class="row-pre">
<pre>
/* 向数组中添加元素时 */

const items = []

// bad
items[items.length] = 'test'

// good
items.push('test')
</pre>
        </li>
        <li class="row-pre">
<pre>
/* 使用拓展运算符 ... 复制数组 */

const items = [1, 2, 3, 4, 5, 6]

// bad
const itemsCopy = []
const len = items.length
let i
for (i = 0; i < len; i++) {
  itemsCopy[i] = items[i]
}

// good
itemsCopy = [...items]
</pre>
        </li>
        <li class="row-pre">
<pre>
/* 使用数组的 map 等方法时，请使用 return 声明，如果是单一声明语句的情况，可省略 return */

// good
[1, 2, 3].map(x => {
  const y = x + 1
  return x * y
})

// good
[1, 2, 3].map(x => x + 1)

// bad
const flat = {}
[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) => {
  const flatten = memo.concat(item)
  flat[index] = flatten
})

// good
const flat = {}
[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) => {
  const flatten = memo.concat(item)
  flat[index] = flatten
  return flatten
})

// bad
inbox.filter((msg) => {
  const { subject, author } = msg
  if (subject === 'Mockingbird') {
    return author === 'Harper Lee'
  } else {
    return false
  }
})

// good
inbox.filter((msg) => {
  const { subject, author } = msg
  if (subject === 'Mockingbird') {
    return author === 'Harper Lee'
  }

  return false
})
</pre>
        </li>
        <li class="title-s2">解构赋值</li>
        <li class="row-pre">
<pre>
/* 当需要使用对象的多个属性时，请使用解构赋值 */

// bad
function getFullName (user) {
  const firstName = user.firstName
  const lastName = user.lastName

  return `${firstName} ${lastName}`
}

// good
function getFullName (user) {
  const { firstName, lastName } = user

  return `${firstName} ${lastName}`
}

// better
function getFullName ({ firstName, lastName }) {
  return `${firstName} ${lastName}`
}
</pre>
        </li>
        <li class="row-pre">
<pre>
/* 当需要使用数组的多个值时，请同样使用解构赋值 */

const arr = [1, 2, 3, 4]

// bad
const first = arr[0]
const second = arr[1]

// good
const [first, second] = arr
</pre>
        </li>
        <li class="row-pre">
<pre>
/* 函数需要回传多个值时，请使用对象的解构，而不是数组的解构 */

// bad
function doSomething () {
  return [top, right, bottom, left]
}

// 如果是数组解构，那么在调用时就需要考虑数据的顺序
const [top, xx, xxx, left] = doSomething()

// good
function doSomething () {
  return { top, right, bottom, left }
}

// 此时不需要考虑数据的顺序
const { top, left } = doSomething()
</pre>
        </li>
        <li class="title-s2">字符串</li>
        <li class="row-pre">
<pre>
/* 字符串统一使用单引号的形式 '' */

// bad
const department = "JDC"

// good
const department = 'JDC'
</pre>
        </li>
        <li class="row-pre">
<pre>
/* 字符串太长的时候，请不要使用字符串连接符换行 \，而是使用 + */

const str = '查查实验室 查查实验室 查查实验室' +
  '查查实验室 查查实验室 查查实验室' +
  '查查实验室 查查实验室'
</pre>
        </li>
        <li class="row-pre">
<pre>
/* 程序化生成字符串时，请使用模板字符串 */

const test = 'test'

// bad
const str = ['a', 'b', test].join()

// bad
const str = 'a' + 'b' + test

// good
const str = `ab${test}`
</pre>
        </li>
        <li class="title-s2">函数</li>
        <li class="row-pre">
<pre>
/* 请使用函数声明，而不是函数表达式 */

// bad
const foo = function () {
  // do something
}

// good
function foo () {
  // do something
}
</pre>
        </li>
        <li class="row-pre">
<pre>
/* 不要在非函数代码块中声明函数 */

// bad
if (isUse) {
  function test () {
    // do something
  }
}

// good
let test
if (isUse) {
  test = () => {
    // do something
  }
}
</pre>
        </li>
        <li class="row-pre">
<pre>
/* 不要使用 arguments，可以选择使用 ... */

// bad
function test () {
  const args = Array.prototype.slice.call(arguments)
  return args.join('')
}

// good
function test (...args) {
  return args.join('')
}
</pre>
        </li>
        <li class="row-pre">
<pre>
/* 不要更改函数参数的值 */

// bad
function test (opts) {
  opts = opts || {}
}

// good
function test (opts = {}) {
  // ...
}
</pre>
        </li>
        <li class="title-s2">原型</li>
        <li class="row-pre">
<pre>
/* 使用 class，避免直接操作 prototype */

// bad
function Queue (contents = []) {
  this._queue = [..contents]
}
Queue.prototype.pop = function () {
  const value = this._queue[0]
  this._queue.splice(0, 1)
  return value
}

// good
class Queue {
  constructor (contents = []) {
    this._queue = [...contents]
  }

  pop () {
    const value = this._queue[0]
    this._queue.splice(0, 1)
    return value
  }
}
</pre>
        </li>
        <li class="title-s2">模块</li>
        <li class="row-pre">
<pre>
/* 使用标准的 ES6 模块语法 import 和 export */

// bad
const util = require('./util')
module.exports = util

// good
import Util from './util'
export default Util

// better
import { Util } from './util'
export default Util
</pre>
        </li>
        <li class="title-s2">对象属性</li>
        <li class="row-pre">
<pre>
/* 使用 . 来访问对象属性 */

const joke = {
  name: 'haha',
  age: 28
}

// bad
const name = joke['name']

// good
const name = joke.name
</pre>
        </li>
        <li class="title-s2">变量声明</li>
        <li class="row-pre">
<pre>
/* 声明变量时，请使用 const、let 关键字，如果没有写关键字，变量就会暴露在全局上下文中，这样很可能会和现有变量冲突，另外，也很难明确该变量的作用域是什么。这里推荐使用 const 来声明变量，我们需要避免全局命名空间的污染。 */

// bad
demo = new Demo()

// good
const demo = new Demo()
</pre>
        </li>
        <li class="title-s2">Hoisting</li>
        <li class="row-pre">
<pre>
/* var 存在变量提升的情况，即 var 声明会被提升至该作用域的顶部，但是他们的赋值并不会。而 const 和 let 并不存在这种情况，他们被赋予了 Temporal Dead Zones, TDZ */

function example () {
  console.log(notDefined)   // => throws a ReferenceError
}

function example () {
  console.log(declareButNotAssigned)  // => undefined
  var declaredButNotAssigned = true
}

function example () {
  let declaredButNotAssigned
  console.log(declaredButNotAssigned)   // => undefined
  declaredButNotAssigned = true
}

function example () {
  console.log(declaredButNotAssigned)   // => throws a ReferenceError
  console.log(typeof declaredButNotAssigned)  // => throws a ReferenceError
  const declaredButNotAssigned = true
}
</pre>
        </li>
        <li class="row-pre">
<pre>
/* 匿名函数的变量名会提升，但函数内容不会 */

function example () {
  console.log(anonymous)  // => undefined

  anonymous()

  var anonymous = function () {
    console.log('test')
  }
}
</pre>
        </li>
        <li class="row-pre">
<pre>
/* 命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会 */

function example() {
  console.log(named)  // => undefined

  named()   // => TypeError named is not a function

  superPower()  // => ReferenceError superPower is not defined

  var named = function superPower () {
    console.log('Flying')
  }
}

function example() {
  console.log(named)  // => undefined

  named()   // => TypeError named is not a function

  var named = function named () {
    console.log('named')
  }
}
</pre>
        </li>
        <li class="row-s1">eval()：由于 eval 方法比较 evil，所以我们约定禁止使用该方法</li>
        <li class="row-s1">with() {}：由于 with 方法会产生神奇的作用域，所以我们也是禁止使用该方法的</li>
      </ul class="main">
    </section>
  </body>
</html>
<script src="./assets/js/jquery-3.2.1.min.js"></script>
<script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
